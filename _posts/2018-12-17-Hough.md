---
layout: post
title: The Hough Transform
categories: [Botzilla]
tags: [Javascript, Algorithms, Machine Learning]
---

<figure class="align-center">
	<canvas width="390" height="266" id="km_sample5" class="align-center">
	</canvas>
  <figcaption id='stats4'>Reduced colors</figcaption>
</figure> 
<button id="reloader" onclick="kmSample4.update_pic_src();" class="btn--primary align-center">Press for a Different Random Photo</button>

<script>
	var kmSample4 = {
		m: null,
		canvas: null,
		ctx: null,
		iter: 0,
		srcImage: null,
		imSize: {x:128,y:128},
		paused: false,
		pinBW: true,
		pxls: null,
		stats: null,
		histo: new Array(256), // how many pixels ahve this value
		member: new Array(256), // for any gra value, what's the "owning" mean (as index into "this.m[]")
		mapped: new Array(256),
		placeHolderURLs: ['https://loremflickr.com/g/128/128/vespa,scooter','https://picsum.photos/g/128/128/?random',"https://www.fillmurray.com/128/128"],
		//
		sat_random_color: function() {
			// returns some strong color. We consider RG&B to be evenly-tempered, no perceptual hijinks
			var c = [Math.random(), Math.random(), Math.random()];
			var v = Math.max.apply(Math,c);
			c = c.map(function(x) { return Math.min(1.0, x/v);});
			var v = 1.0 - Math.min.apply(Math,c);
			c = c.map(function(x) { return Math.max(0.0, (1.0-x)/v);});
			c = c.map(function(x) { return Math.min(255, Math.floor(255*x));});
			return c;
		},
		init_sample_data: function(nMeans) {
			// let's randomly place a few mean candidates
			this.m = [];
			for (var i=0; i<nMeans; i=i+1) {
				var cv = this.sat_random_color(); // for our mean markers
				var fv, pin;
				if (this.pinBW && (i>=(nMeans-2))) {
					fv = (i==(nMeans-1))?255:0;
					pin = true;
				} else {
					fv = 256*Math.random();
					pin = false;
				}
				var iv = Math.floor(fv);
				this.m.push({
					v: fv,
					i: iv,
					cv: cv,
					c: ('rgb('+cv.join(',')+')'),
					active: true,
					pinned: pin
				});
			}
		},
		filterImage: filterImage = function(filter, image, var_args) {
		  var args = [this.getPixels(image)];
		  for (var i=2; i<arguments.length; i++) {
		    args.push(arguments[i]);
		  }
		  return filter.apply(null, args);
		},
		convolute: function(pixels, weights, opaque) {
		  var side = Math.round(Math.sqrt(weights.length));
		  var halfSide = Math.floor(side/2);
		  var src = pixels.data;
		  var sw = pixels.width;
		  var sh = pixels.height;
		  // pad output by the convolution matrix
		  var w = sw;
		  var h = sh;
		  var output = Filters.createImageData(w, h);
		  var dst = output.data;
		  // go through the destination image pixels
		  var alphaFac = opaque ? 1 : 0;
		  for (var y=0; y<h; y++) {
		    for (var x=0; x<w; x++) {
		      var sy = y;
		      var sx = x;
		      var dstOff = (y*w+x)*4;
		      // calculate the weighed sum of the source image pixels that
		      // fall under the convolution matrix
		      var r=0, g=0, b=0, a=0;
		      for (var cy=0; cy<side; cy++) {
			for (var cx=0; cx<side; cx++) {
			  var scy = sy + cy - halfSide;
			  var scx = sx + cx - halfSide;
			  if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
			    var srcOff = (scy*sw+scx)*4;
			    var wt = weights[cy*side+cx];
			    r += src[srcOff] * wt;
			    g += src[srcOff+1] * wt;
			    b += src[srcOff+2] * wt;
			    a += src[srcOff+3] * wt;
			  }
			}
		      }
		      dst[dstOff] = r;
		      dst[dstOff+1] = g;
		      dst[dstOff+2] = b;
		      dst[dstOff+3] = a + alphaFac*(255-a);
		    }
		  }
		  return output;
		},
		distance1D: function(v,m) {
			// distance between a pixel value and a mean.
			return Math.abs(v-m.v);
		},
		padz: function(n, width, z) {
		  z = z || '0';
		  n = n + '';
		  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
		},
		draw_pic: function(x,y) {
			if (this.pxls != null) {
				this.ctx.putImageData(this.pxls, x, y);
			} else {
				this.ctx.drawImage(this.srcImage, x,y); // , this.imSize.x,this.imSize.y);
			}
		},
		draw_histo: function(x,y) {
			var i;
			for (i=0; i<this.m.length; i+=1) {
				var m = this.m[i];
				if (!m.active) {
					continue;
				}
				if (!this.m[i].pinned) {
					this.ctx.strokeStyle = m.c;
					var xx = ((255-m.i)+x);
					this.ctx.beginPath();
					this.ctx.moveTo(xx,y);
					this.ctx.lineTo(xx,y+256);
					this.ctx.stroke();
				}
			}
			var g = this.ctx.createLinearGradient(x, y, x+256, y);
			g.addColorStop(1, '#101010ff');
			g.addColorStop(0, '#e0e0e0ff');
			this.ctx.fillStyle='black';
			this.ctx.strokeStyle=g;
			for (i=0; i<256; i+=1) {
				this.ctx.beginPath();
				this.ctx.moveTo((255-i)+x, y+256);
				this.ctx.lineTo((255-i)+x, y+256-this.histo[i]);
				this.ctx.stroke();
			}
		},
		draw_points: function(x0,y0) {
			var i, j, p, x, y;
			for (i=0; i<256; i+=1) {
				this.mapped[i] = this.m[this.member[i]].i;
			}
			for (j=0; j<this.pxls.data.length; j+=4) {
				p = this.pxls.data[j];
				p = this.mapped[p];
				this.result.data[j] = p;
				this.result.data[j+1] = p;
				this.result.data[j+2] = p;
				this.result.data[j+3] = 255;
			}
			this.ctx.putImageData(this.result, x0, y0);
		},
		update_canvas: function() {
			// draw points AND means
			this.ctx.fillStyle = 'white';
			this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)
			this.draw_pic(0,0);
			this.draw_points(0,128);
			this.draw_histo(128,0);
		},
		update_memberships: function() {
			// update points, to see if any have switched affiliations. Return a count of
			//     how many have changed.
			var ip, im;
			var nChanged = 0;
			for (ip=0; ip<256; ip=ip+1) {
				var dBest = 2000; // some large value beyond our 256-value range
				var mBest = null;
				for (im=0; im<this.m.length; im=im+=1) {
					if (!this.m[im].active)
						continue;
					var dm = Math.abs(ip - this.m[im].v);
					if (dm<dBest) {
						dBest = dm;
						mBest = im;
					}
				}
				if (mBest != this.member[ip]) {
					nChanged += 1;
					this.member[ip] = mBest;
				}
			}
			// console.log(nChanged+' changed');
			return(nChanged);
		},
		update_centroids: function() {
			// update mean locations (ignore inactive ones)
			var ip, im, n, c;
			for (im=0; im<this.m.length; im+=1) {
				if (!this.m[im].active)
					continue;
				n = 0;
				c = 0;
				for (ip=0; ip<256; ip+=1) {
					if (this.member[ip] == im) {
						n += this.histo[ip];
						c += ip*this.histo[ip];
					}
				}
				if (n==0) { // set is EMPTY - can be discarded
					if (!this.m[im].pinned) {
						this.m[im].active = false;
					}
					// console.log("mean "+im+' has no membership, value '+this.m[im].i);
				} else { // move to centroid of member points
					if (!this.m[im].pinned) {
						this.m[im].v = c/n;
						this.m[im].i = Math.floor(this.m[im].v);
					}
				}
			}
			this.update_stats();
		},
		update_stats: function() {
			if (!this.stats) {
				this.stats = document.getElementById('stats4');
			}
			var i, c;
			for (i=0,c=0; i<this.m.length; i+=1) {
				if (this.m[i].active) c += 1;
			}
			text = (this.pinBW) ? ((c-1).toString()+' <b>inks:</b>') : (c.toString()+' colors:');
			var actives = [];
			for (i=0; i<this.m.length; i+=1) {
				if (this.m[i].active) {
					actives.push(this.m[i].i);
				}
			}
			actives.sort(function(a,b){return b-a;});
			for (i=0; i<actives.length; i+=1) {
				if ((!this.pinBW) || (actives[i]!=255)) {
					var ink = (actives[i] == 0) ? '&amp; black' : (Math.floor((100*(255-actives[i])/255)).toString()+'%,');
					text = text+' '+ink;
				}
			}
			this.stats.innerHTML = text;
		},
		update_all: function() {
			// our complete method -- just loop on this until you don't
			var m = this.update_memberships();
			if (m > 0) {
				this.update_centroids();
			}
			return(m);
		},
		remove_one: function() {
			// randomly remove a mean, until we reach some minimum
			var i, ct;
			for (i=0; i<this.m.length; i+=1) {
				if (this.m[i].active) {
					if (!this.m[i].pinned)
						this.m[i].active = false;
					break;
				}
			}
			for (i=0, ct=0; i<this.m.length; i+=1) {
				if (this.m[i].active) {
					ct += 1;
				}
			}
			return (ct > 2);
		},
		looper: function(timestamp) {
			// called by requestAnimationFrame() forever
			if (this.paused) {
				window.requestAnimationFrame(this.looper.bind(this));
				return;
			}
			var ch = this.update_all();
			this.update_canvas();
			if (ch > 0) {
				window.requestAnimationFrame(this.looper.bind(this));
			} else if (this.remove_one()) {
				window.setTimeout(this.looper.bind(this),2000);
			} else {
				window.setTimeout(this.startup.bind(this),4000);
			}
			this.iter += 1;
		},
		startup: function() {
			// also called whenever we re-start
			this.init_sample_data(6+Math.floor(6*Math.random()));
			this.iter = 0;
			window.requestAnimationFrame(this.looper.bind(this));
		},
		collect_gray_pixels: function(context,x0,y0,w,h) {
			var i;
			this.pxls = context.getImageData(x0,y0,w,h);
			this.result = context.createImageData(w, h);
			// but we only care about the gray, so
			var grayscale = function(ctx,rgba) {
				var data = rgba.data;
			    for (var i = 0; i < data.length; i += 4) {
			      var avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
			      data[i]     = avg; // red
			      data[i + 1] = avg; // green
			      data[i + 2] = avg; // blue
			    }
			    ctx.putImageData(rgba, 0, 0);
			  };
			grayscale(context,this.pxls);
			// preparing a histogram will make later calculations faster
			for (i=0; i< 256; i+=1) {
				this.histo[i] = 0;
				this.member[i] = null; // for each gray value, which is the closest mean?
			}
			for (i=0; i<this.pxls.data.length; i+=4) {
				//var v = (this.pxls.data[i] + this.pxls.data[i+1] + this.pxls.data[i+2])/3;
				var v = this.pxls.data[i];
				this.histo[ v ] += 1;
			}
		},
		init_pic_from_image: function() {
			if (!this.srcImage) {
				this.srcImage = document.getElementById('gray4');
			}
			this.imSize.x = this.srcImage.width;
			this.imSize.y = this.srcImage.height;
			var srcCanv = document.createElement('canvas');
			srcCanv.width = this.imSize.x;
			srcCanv.height = this.imSize.y;
			var srcCtx = srcCanv.getContext('2d');
			srcCtx.drawImage(this.srcImage, 0,0);
			this.collect_gray_pixels(srcCtx,0,0,this.srcImage.width,this.srcImage.height);
		},
		toggle_pause: function() {
			// user can click to stop/start the animation
			this.paused = ! this.paused;
		},
		main: function(canvID,srcImg) {
			this.canvas = document.getElementById(canvID);
			var p = this.canvas.parentElement;
			if (p.offsetWidth < (this.canvas.width-4)) {
				this.canvas.width = p.offsetWidth - 4;
			}
			this.ctx = this.canvas.getContext('2d');
			this.canvas.onclick = this.toggle_pause.bind(this);
			this.init_pic_from_image();
			this.startup();
		},
		update_pic_src: function() {
			if (this.srcImage) {
				console.log("reload");
				var env = "{{ jekyll.environment }}";
				this.srcImage.src = (env == 'development') ? "/img/misc/c-scoot.jpg" : ('https://picsum.photos//128/128/?random&junk='+new Date().getTime());
			} else {
				console.log("button pressed too soon?");
			}
		},
		begin: function() {
			// load an interesting pic
			this.srcImage = new Image();
			this.srcImage.setAttribute('id','gray4');
			this.srcImage.setAttribute('crossOrigin','anonymous');
			this.srcImage.onload = function() {
				this.main("km_sample5");
			}.bind(this);
			this.update_pic_src();
		}
	};
	kmSample4.begin();
</script>

_Part of a brief series that started [here.]({{ site.baseurl}}{% post_url 2018-12-05-K-Means %})_
{: .notice--info}

My favorite definition for mathematics is: _the study of patterns._

<!--more-->
### The Idea

The Hough Transform is cool.

### The Example

Extracting edges can be straightforward using _convolutions._ Convolutions are cool but not the direct topic of this post, so we'll borrow the convolution code [here on "html5rocks.com"](https://www.html5rocks.com/en/tutorials/canvas/imagefilters/)


