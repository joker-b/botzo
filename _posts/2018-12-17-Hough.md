---
layout: post
title: The Hough Transform
categories: [Botzilla]
tags: [Javascript, Algorithms, Machine Learning]
---

<figure class="align-center">
	<canvas width="392" height="392" id="km_sample5" class="align-center">
	</canvas>
  <figcaption id='htStats'>Lines from Pixels</figcaption>
</figure>
<button id="reloader" onclick="htSample1.update_pic_src();" class="btn--primary align-center">Press for a Different Random Photo</button>

<script>
	// Hough Transform Sample Points that bounce around in their little windows
	function bouncePt(x,y,vx,vy,decay) {
		this.x = x ? x : 0;
		this.y = y ? y : 0;
		this.vx = vx ? vx : 0;
		this.vy = vy ? vy : 0;
		this.decay = (decay===undefined) ? 0.999 : decay;
	}
	bouncePt.prototype.advance = function(w,h)
	{
		this.x += this.vx;
		this.y += this.vy;
		if ((this.x<0)||(this.x>=w)) {
			this.vx = -this.vx + (Math.random()*3-1.5);
			this.vy += (Math.random()-0.5);
		}
		if ((this.y<0)||(this.y>=h)) {
			this.vx += Math.random()-0.5;
			this.vy = -this.vy + (Math.random()*3-1.5);
		}
		this.vx *= this.decay;
		this.vy *= this.decay;
		this.x = this.x<0 ? -this.x : this.x;
		this.x = this.x>=w ? 2*w-this.x-1 : this.x;
		this.y = this.y<0 ? -this.y : this.y;
		this.y = this.y>=h ? 2*h-this.y-1 : this.y;
	}
	bouncePt.prototype.crosshair = function(ctx,x0,y0,w,h) {
		ctx.strokeStyle = '#b0ffb0ff';
		var nx = x0+this.x;
		var ny = y0+this.y;
		ctx.beginPath();
		ctx.moveTo(nx,y0);
		ctx.lineTo(nx,y0+h-1);
		ctx.moveTo(x0,ny);
		ctx.lineTo(x0+w-1,ny);
		ctx.stroke();
		ctx.strokeStyle = '#a0a0a0ff';
		ctx.beginPath();
		ctx.rect(x0,y0,w,h);
		var d = 2;
		ctx.moveTo(nx-d,ny-d);
		ctx.lineTo(nx+d,ny+d);
		ctx.moveTo(nx-d,ny+d);
		ctx.lineTo(nx+d,ny-d);
		ctx.stroke();
		ctx.fillStyle = 'black';
		ctx.fillRect(nx,ny,1,1);  	
	}
	//
	var htSample1 = {
		canvas: null,
		ctx: null,
		canvasB: null,
		ctxB: null,
		canvasC: null,
		ctxC: null,
		iter: 0,
		pauseCount: 0,
		srcImage: null,
		paused: false,
		// various imageData objects
		origPxls: null,
		grayPxls: null,
		edgePxls: null,
		mixdPxls: null,
		linePxls: null,
		mixdPxls: null,
		overPxls: null,
		aSize: {x:256, y:128},
		aPxls: null,
		cosa: null,
		sina: null,
		maxP: null,
		accumulator: null,
		samplePtB: new bouncePt(64, 64, (Math.random()*5)-2.5, (Math.random()*5)-2.5),
		samplePtC: new bouncePt(128, 64, (Math.random()*7)-3.5, (Math.random()*5)-2.5),
		stats: null,
		debug: false,
		placeHolderURLs: ['https://loremflickr.com/g/128/128/vespa,scooter','https://picsum.photos/g/128/128/?random',"https://www.fillmurray.com/128/128"],
		//
		filters: { // based on https://www.html5rocks.com/en/tutorials/canvas/imagefilters/
			filterImage: function(filter, image, var_args) {
			  var args = [this.getPixels(image)];
			  for (var i=2; i<arguments.length; i++) {
			    args.push(arguments[i]);
			  }
			  return filter.apply(null, args);
			},
			grayscale: function(pixels, args) {
			  var d = pixels.data;
			  for (var i=0; i<d.length; i+=4) {
			    var v = (d[i]+d[i+1]+d[i+2])/3;
			    d[i] = d[i+1] = d[i+2] = v;
			  }
			  return pixels;
			},
			grayscale_lum: function(pixels, args) {
			  var d = pixels.data;
			  for (var i=0; i<d.length; i+=4) {
			    var r = d[i];
			    var g = d[i+1];
			    var b = d[i+2];
			    // CIE luminance for the RGB
			    // The human eye is bad at seeing red and blue, so we de-emphasize them.
			    var v = 0.2126*r + 0.7152*g + 0.0722*b;
			    d[i] = d[i+1] = d[i+2] = v;
			  }
			  return pixels;
			},
			convolute: function(pixels, weights, opaque) {
			  var side = Math.round(Math.sqrt(weights.length));
			  var halfSide = Math.floor(side/2);
			  var src = pixels.data;
			  var sw = pixels.width;
			  var sh = pixels.height;
			  // pad output by the convolution matrix
			  var w = sw;
			  var h = sh;
			  var output = Filters.createImageData(w, h);
			  var dst = output.data;
			  // go through the destination image pixels
			  var alphaFac = opaque ? 1 : 0;
			  for (var y=0; y<h; y++) {
			    for (var x=0; x<w; x++) {
			      var sy = y;
			      var sx = x;
			      var dstOff = (y*w+x)*4;
			      // calculate the weighed sum of the source image pixels that
			      // fall under the convolution matrix
			      var r=0, g=0, b=0, a=0;
			      for (var cy=0; cy<side; cy++) {
				for (var cx=0; cx<side; cx++) {
				  var scy = sy + cy - halfSide;
				  var scx = sx + cx - halfSide;
				  if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
				    var srcOff = (scy*sw+scx)*4;
				    var wt = weights[cy*side+cx];
				    r += src[srcOff] * wt;
				    g += src[srcOff+1] * wt;
				    b += src[srcOff+2] * wt;
				    a += src[srcOff+3] * wt;
				  }
				}
			      }
			      dst[dstOff] = r;
			      dst[dstOff+1] = g;
			      dst[dstOff+2] = b;
			      dst[dstOff+3] = a + alphaFac*(255-a);
			    }
			  }
			  return output;
			},
			convoluteFloat32: function(pixels, weights, opaque) {
	          var side = Math.round(Math.sqrt(weights.length));
	          var halfSide = Math.floor(side/2);

	          var src = pixels.data;
	          var sw = pixels.width;
	          var sh = pixels.height;

	          var w = sw;
	          var h = sh;
	          var output = {
	            width: w, height: h, data: new Float32Array(w*h*4)
	          };
	          var dst = output.data;

	          var alphaFac = opaque ? 1 : 0;

	          for (var y=0; y<h; y++) {
	            for (var x=0; x<w; x++) {
	              var sy = y;
	              var sx = x;
	              var dstOff = (y*w+x)*4;
	              var r=0, g=0, b=0, a=0;
	              for (var cy=0; cy<side; cy++) {
	                for (var cx=0; cx<side; cx++) {
	                  var scy = Math.min(sh-1, Math.max(0, sy + cy - halfSide));
	                  var scx = Math.min(sw-1, Math.max(0, sx + cx - halfSide));
	                  var srcOff = (scy*sw+scx)*4;
	                  var wt = weights[cy*side+cx];
	                  r += src[srcOff] * wt;
	                  g += src[srcOff+1] * wt;
	                  b += src[srcOff+2] * wt;
	                  a += src[srcOff+3] * wt;
	                }
	              }
	              dst[dstOff] = r;
	              dst[dstOff+1] = g;
	              dst[dstOff+2] = b;
	              dst[dstOff+3] = a + alphaFac*(255-a);
	            }
	          }
	          return output;
	        },
			sobel: function(px,edgePx) {
				// px = Filters.grayscale(px); // let's assume it's already gray
				// original method created edgePx, but we can avoid reallocations
				// Note that ImageData values are clamped between 0 and 255, so we need
				// to use a Float32Array for the gradient values because they
				// range between -255 and 255.
				var vertical = this.convoluteFloat32(px,
				  [ -1, 0, 1,
				    -2, 0, 2,
				    -1, 0, 1 ]);
				var horizontal = this.convoluteFloat32(px,
				  [ -1, -2, -1,
				     0,  0,  0,
				     1,  2,  1 ]);
				//var edgePx = Filters.createImageData(vertical.width, vertical.height);
				for (var i=0; i<edgePx.data.length; i+=4) {
				  // make the vertical gradient red
				  var v = Math.abs(vertical.data[i]);
				  edgePx.data[i] = v;
				  // make the horizontal gradient green
				  var h = Math.abs(horizontal.data[i]);
				  edgePx.data[i+1] = h;
				  // and mix in some blue for aesthetics
				  edgePx.data[i+2] = (v+h)/4;
				  edgePx.data[i+3] = 255; // opaque alpha
				}
				return edgePx;
			},
		},
		accumulate_hough_points: function(y) {
		  // look for potential edge points in row "y" of edgePxls, add to our accumulator
			var t = 0;
			for (var x=0; x<this.edgePxls.width; x+=1) {
				var i = x + y*this.edgePxls.width;
				var j = i*4;
				var hh = this.aSize.y / 2;
				var v = this.edgePxls.data[j] + this.edgePxls.data[j+1];
				if (v > 190) {	// TODO: threshhold value
					for(k=0; k<this.aSize.x; k+=1) { // iterate through possible angles
						var p = x*this.cosa[k] + y*this.sina[k];
						var pn = Math.floor(hh + hh * p / this.maxP);
						if (p<0) {
							t += 1;
						}
						var accIndex = pn*this.aSize.x + k;
						this.accumulator[accIndex] += 1;
					}
				}
			}
		},
		update_hough_pixels: function() {
		  // interpret our floating-point accumulator as an 8-bit image
			this.maxA = Math.max.apply(Math, this.accumulator);
			if (this.maxA == 0.0) {
				// TODO
				return;
			}
			for (var i=0; i<this.accumulator.length; i+=1) {
				var j = i*4;
				var v = Math.floor(255*this.accumulator[i]/this.maxA);
				this.aPxls.data[j] = this.aPxls.data[j+1] = this.aPxls.data[j+2] = v;
			}
		},
		update_hough_lines: function(x0, y0) {
			this.ctx.save();
			// this version draws red lines and a "scanner" line over the grayscale image
			// this.ctx.fillStyle = 'white';
			// this.ctx.fillRect(x0,y0,this.edgePxls.width,this.edgePxls.height);
			var w = this.grayPxls.width;
			var h = this.grayPxls.height;
			this.ctx.putImageData(this.grayPxls, x0, y0);
			this.ctx.beginPath();
			this.ctx.rect(x0,y0,w,h);
			this.ctx.clip();
			if (this.iter< h) {
				this.ctx.strokeStyle = 'blue';
				this.ctx.moveTo(x0,   y0+this.iter);
				this.ctx.lineTo(x0+w, y0+this.iter);
				this.ctx.stroke();
			}
			// this.maxA = Math.max.apply(Math, this.accumulator); // also calc'd in update_hough_pixels()
			if (this.maxA < 1) {
				this.ctx.restore();
				return 0;
			}
			this.ctx.strokeStyle = '#20ff0040';
			var i = 0;
			var n = 0;
			var mx = w-1;
			var hh = this.aSize.y / 2;
			for (var y=0; y<this.aSize.y; y+=1) {
				for (var x=0; x<this.aSize.x; x+=1) {
					if (this.accumulator[i] >= (this.maxA*0.8)) { // TODO: tune this
						var p = this.maxP*((y-hh)/hh);
						this.ctx.beginPath();
						if (this.sina[x] != 0.0) {
							var yz = (p-0*this.cosa[x])/this.sina[x];
							var ym = (p-mx*this.cosa[x])/this.sina[x];
							this.ctx.moveTo(x0+0, y0+yz);
							this.ctx.lineTo(x0+mx,y0+ym);
						} else {
							this.ctx.moveTo(x0+p,y0);
							this.ctx.lineTo(x0+p,y0+h);
						}
						this.ctx.stroke();
						n += 1;
					}
					i += 1;
				}
			}
			this.ctx.restore();
			// console.log(n+' strokes');
			return n;
		},
		update_hough_lines_only: function(x0, y0) {
			// this version draws white lines on black, no "scanner"
			var w = this.grayPxls.width;
			var h = this.grayPxls.height;
			this.ctx.save();
			this.ctx.fillStyle = 'black';
			this.ctx.fillRect(x0,y0,w,h);
			// this.maxA = Math.max.apply(Math, this.accumulator); // also calc'd in update_hough_pixels()
			if (this.maxA < 1) {
				this.ctx.restore();
				return 0;
			}
			this.ctx.beginPath();
			this.ctx.rect(x0,y0,w,h);
			this.ctx.clip();
			this.ctx.strokeStyle = '#ffffffff';
			var i = 0;
			var n = 0;
			var mx = w-1;
			var hh = this.aSize.y / 2;
			for (var y=0; y<this.aSize.y; y+=1) {
				for (var x=0; x<this.aSize.x; x+=1) {
					if (this.accumulator[i] >= (this.maxA*0.8)) { // TODO: tune this
						var p = this.maxP*((y-hh)/hh);
						this.ctx.beginPath();
						if (this.sina[x] != 0.0) {
							var yz = (p-0*this.cosa[x])/this.sina[x];
							var ym = (p-mx*this.cosa[x])/this.sina[x];
							this.ctx.moveTo(x0+0,y0+yz);
							this.ctx.lineTo(x0+mx,y0+ym);
						} else {
							this.ctx.moveTo(x0+p,y0);
							this.ctx.lineTo(x0+p,y0+h);
						}
						this.ctx.stroke();
						n += 1;
					}
					i += 1;
				}
			}
			this.ctx.restore();
			// console.log(n+' strokes');
			return n;
		},
		edge_mix: function() {
			for (var i=0; i<this.mixdPxls.data.length; i+=4) {
				var l = this.linePxls.data[i];
				var e = Math.min(255,this.edgePxls.data[i]+this.edgePxls.data[i+1]);
				var m = l * e / 255;
				this.mixdPxls.data[i] =
				this.mixdPxls.data[i+1] =
				this.mixdPxls.data[i+2] = m;
				this.mixdPxls.data[i+3] = 255;
				var g = this.grayPxls.data[i];
				var f = m > 128;
				this.overPxls.data[i]   = f ? m : g;
				this.overPxls.data[i+1] = f ? 0 : g;
				this.overPxls.data[i+2] = f ? 0 : g;
				this.overPxls.data[i+3] = 255;
			}
		},
		update_canvas: function() {
			// draw points AND means
			this.ctx.fillStyle = 'white';
			this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
			if (this.origPxls == null) { // should be a very rare case
				this.ctx.drawImage(this.srcImage, 0,0);
				this.ctx.strokeStyle = 'red';
				this.ctx.beginPath();
				this.ctx.moveTo(128,0);
				this.ctx.lineTo(255,127);
				this.ctx.lineTo(383,0);
				this.ctx.moveTo(128,127);
				this.ctx.lineTo(255,0);
				this.ctx.lineTo(383,127);
				this.ctx.stroke();
				return;
			}
			this.ctx.putImageData(this.origPxls, 0, 0);
			this.ctx.putImageData(this.grayPxls, 132, 0);
			this.ctx.putImageData(this.edgePxls, 262, 0);
			this.ctx.putImageData(this.aPxls, 0, 132);
			var nLines = this.update_hough_lines(262,132);
			var nLines2 = this.update_hough_lines_only(0,262);
			this.linePxls = this.ctx.getImageData(0,262,this.edgePxls.width,this.edgePxls.height);
			this.edge_mix();
			this.ctx.putImageData(this.mixdPxls, 132, 262);
			this.ctx.putImageData(this.overPxls, 262, 262);
			this.update_stats(nLines);
		},
		update_canvasB: function() {
			// canvasB shows a sample point in x/y and draws a matching curve of 
			//    possible theta/rho values across the range of theta of +/- 90 degrees
			if (! this.canvasB) return;
			var w = this.edgePxls.width;
			var h = this.edgePxls.height;
			this.samplePtB.advance(w,h);
			this.ctxB.fillStyle = 'white';
			this.ctxB.fillRect(0,0,w,h);
			this.samplePtB.crosshair(this.ctxB,0,0,w,h);
			this.ctxB.fillStyle = 'black';
			this.ctxB.fillRect(w+4,0,this.aSize.x,this.aSize.y);
			this.ctxB.fillStyle = 'white';
			var x = this.samplePtB.x;
			var y = this.samplePtB.y;
			var hh = this.aSize.y / 2;
			for(var k=0; k<this.aSize.x; k+=1) { // iterate through possible angles
				var p = x*this.cosa[k] + y*this.sina[k];
				var pn = Math.floor(hh + hh * p / this.maxP);
				this.ctxB.fillRect(w+4+k,pn,1,1);
			}
		},
		update_canvasC: function() {
			// canvasC shows a simple point in theta/rho and draws a line in x/y
			if (! this.canvasC) return;
			var aw = this.aSize.x;
			var ah = this.aSize.y;
			var w = this.edgePxls.width;
			var h = this.edgePxls.height;
			this.samplePtC.advance(aw,ah);
			var x = this.samplePtC.x;
			var y = this.samplePtC.y;
			this.ctxC.fillStyle = 'white';
			this.ctxC.fillRect(0,0,aw,ah);
			this.samplePtC.crosshair(this.ctxC,0,0,aw,ah);
			this.ctxC.fillStyle = 'black';
			this.ctxC.fillRect(aw+4,0,w,h);
			this.ctxC.strokeStyle = 'white';
			var r = 0.5*Math.sqrt(w*w + h*h);
			var k = Math.floor(this.samplePtC.x);
			var ck = this.cosa[k];
			var sk = this.sina[k];
			var p = (y-this.aSize.y/2)/(this.aSize.y);
			var cx = aw+4 + w/2;
			var cy = h/2;
			cx += p * r * ck;
			cy += p * r * sk;
			this.ctxC.save();
			this.ctxC.beginPath();
			this.ctxC.rect(aw+4,0,w,h);
			this.ctxC.clip();
			this.ctxC.beginPath();
			this.ctxC.moveTo(cx+r*2*sk,cy+r*2*ck);
			this.ctxC.lineTo(cx-r*2*sk,cy-r*2*ck);
			this.ctxC.stroke();
			this.ctxC.restore();
		},
		update_stats: function(counter) {
			if (!this.stats) {
				this.stats = document.getElementById('htStats');
			}
			text = 'Found '+counter+' strongest line';
			if (counter>1) {
				text = text+'s';
			}
			// if (this.debug) {
			// 	text = text + ', maxA: '+Math.floor(this.maxA);
			// }
			this.stats.innerHTML = text;
		},
		update_all: function() {
			if (this.iter >= this.origPxls.height) {
				return 0;
			}
			this.accumulate_hough_points(this.iter);
			this.update_hough_pixels();
			return 1;
		},
		looper: function(timestamp) {
			// called by requestAnimationFrame() forever
			if (this.paused) {
				window.requestAnimationFrame(this.looper.bind(this));
				return;
			}
			var ch = this.update_all();
			if (this.pauseCount < 1) {
				this.update_canvas();
			}
			this.update_canvasB();
			this.update_canvasC();
			if (ch > 0) {
				this.iter += 1;
			} else {
				this.pauseCount += 1;
			}
			if (this.pauseCount > 200) {
				window.setTimeout(this.update_pic_src.bind(this),30);
			} else {
				window.requestAnimationFrame(this.looper.bind(this));
			}
		},
		startup: function() {
			// also called whenever we re-start animation
			this.iter = this.pauseCount = 0;
			window.requestAnimationFrame(this.looper.bind(this));
		},
		collect_gray_pixels: function(context,x0,y0,w,h) {
			var i;
			this.origPxls = context.getImageData(x0,y0,w,h);
			if (this.grayPxls === null) {
				this.grayPxls = context.createImageData(w, h);
			}
			if (this.edgePxls === null) {
				this.edgePxls = context.createImageData(w, h);
			}
			if (this.mixdPxls === null) {
				this.mixdPxls = context.createImageData(w, h);
			}
			if (this.overPxls === null) {
				this.overPxls = context.createImageData(w, h);
			}
			for (i = 0; i < this.origPxls.data.length; i+=1) {
				this.grayPxls.data[i] = this.origPxls.data[i];
			}
			//this.grayPxls = this.filters.grayscale(this.grayPxls);
			this.filters.grayscale_lum(this.grayPxls);
			this.filters.sobel(this.grayPxls, this.edgePxls);
			// prep accumulation for Hough transform
			this.maxP = Math.sqrt(this.edgePxls.width * this.edgePxls.width +
									this.edgePxls.height * this.edgePxls.height);
			this.maxA = 0.0;
			if (this.accumulator === null) {
				this.accumulator = new Float32Array(this.aSize.x * this.aSize.y);
				this.aPxls = context.createImageData(this.aSize.x, this.aSize.y);
				this.cosa = new Float32Array(this.aSize.x);
				this.sina = new Float32Array(this.aSize.x);
				for (i = 0; i < this.aSize.x; i+=1) {
					var a = Math.PI*(i/(this.aSize.x-1)) - (Math.PI/2);
					this.cosa[i] = Math.cos(a);
					this.sina[i] = Math.sin(a);
				}
			}
			for (i = 0; i < this.accumulator.length; i+=1) {
				this.accumulator[i] = 0.0;
			}
			for (i = 0; i < this.aPxls.data.length; i+=4) {
				this.aPxls.data[i] =
				this.aPxls.data[i+1] =
				this.aPxls.data[i+2] = 0;
				this.aPxls.data[i+3] = 255;
			}
		},
		init_pic_from_image: function() {
			if (!this.srcImage) {
				this.srcImage = document.getElementById('htSrcImg');
			}
			var srcCanv = document.createElement('canvas');
			srcCanv.width = this.srcImage.width;
			srcCanv.height = this.srcImage.height;
			var srcCtx = srcCanv.getContext('2d');
			srcCtx.drawImage(this.srcImage, 0,0);
			this.collect_gray_pixels(srcCtx,0,0,this.srcImage.width,this.srcImage.height);
		},
		toggle_pause: function() {
			// user can click to stop/start the animation
			this.paused = ! this.paused;
		},
		main: function(canvID,srcImg) {
			// called once we have a source image
			this.canvas = document.getElementById(canvID);
			var p = this.canvas.parentElement;
			if (p.offsetWidth < (this.canvas.width-4)) {
				this.canvas.width = p.offsetWidth - 4;
			}
			this.ctx = this.canvas.getContext('2d');
			this.canvas.onclick = this.toggle_pause.bind(this);
			this.canvasB = document.getElementById(canvID+'B');
			if (this.canvasB) {
				this.ctxB = this.canvasB.getContext('2d');
			}
			this.canvasC = document.getElementById(canvID+'C');
			if (this.canvasC) {
				this.ctxC = this.canvasC.getContext('2d');
			}
			// TODO: enable button to simplify update_pic_src()?
			this.init_pic_from_image();
			this.startup();
		},
		update_pic_src: function() {
			if (this.srcImage) {
				//this.srcImage.src = this.debug ? "/img/misc/c-scoot.jpg" : ('https://picsum.photos//128/128/?random&junk='+new Date().getTime());
				this.srcImage.src = ('https://picsum.photos//128/128/?random&junk='+new Date().getTime());
			} else {
				// how could we have gotten here???
				console.log("Warning! button pressed too soon?");
			}
		},
		begin: function() {
			var env = "{{ jekyll.environment }}";
			this.debug = (env == 'development');
			// load an interesting pic before we try anything else
			this.srcImage = new Image();
			this.srcImage.setAttribute('id','htSrcImg');
			this.srcImage.setAttribute('crossOrigin','anonymous');
			this.srcImage.onload = function() {
				this.main("km_sample5");
			}.bind(this);
			this.update_pic_src();
		}
	};
	htSample1.begin();
</script>

_Part of a brief series that started [here.]({{ site.baseurl}}{% post_url 2018-12-05-K-Means %})_
{: .notice--info}

_The study of patterns._

Any kind of pattern: art, physics, music... sometimes the patterns are hard to fathom at first, but unexpectedly, like the sudden twist in a mysterious story, _Aha!_

With that possibility in mind, here's a paradoxical pattern to consider: when is a point a line, and when is line a point, especially when that line is.. a curve?

That's where the _Hough Transform_ comes in.

<!--more-->
### The Idea

X & Y to.. something else

The Hough Transform was first described in the 1950's, by a scientist (Hough) studying bubble-chamber photos. The problem he was trying to get at was: how to find straight lines in very-sketchy, incomplete pictures?



<figure class="align-center">
	<canvas width="392" height="130" id="km_sample5B" class="align-center">
	</canvas>
  <figcaption id='htStatsB'>For any pixel on the image plane, there will be infinitely many possible combinations of &theta; (horizontal) and &rho; (vertical) that describe lines that pass through that point. Here we show the possible values between -90 and 90 degrees of &theta;</figcaption>
</figure>

<figure class="align-center">
	<canvas width="392" height="130" id="km_sample5C" class="align-center">
	</canvas>
  <figcaption id='htStatsC'>Similarly, any point on the &theta;/&rho; plane represents line in the image plane.</figcaption>
</figure>


### The Example

Extracting edges can be straightforward using _convolutions._ Convolutions are cool but not the direct topic of this post, so we'll borrow the convolution code [here on "html5rocks.com"](https://www.html5rocks.com/en/tutorials/canvas/imagefilters/)


